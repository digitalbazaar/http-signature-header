#!/usr/bin/env node

const program = require('commander');
const httpSigs = require('../lib/');
const fs = require('fs');
const util = require('util');
const httpMessageParser = require('http-message-parser');

// this can be use to await paths to private keys and other files.
// also can get be used to dereference keyId in middleware
const readFile = util.promisify(fs.readFile);

/**
 * Simple wrapper around node's process.stdin.
 * This allows us to get the result of cat and other commands.
 *
 * @param {string} [encoding='utf8'] - The http message's encoding.
 *
 * @returns {Promise<string>} Should return the http message.
 */
async function getStdin(encoding = 'utf8') {
  const {stdin} = process;
  let message = '';
  return new Promise((resolve, reject) => {
    try {
      stdin.setEncoding(encoding);
      stdin.on('readable', () => {
        let chunk;
        while((chunk = stdin.read())) {
          message += chunk;
        }
      });
      stdin.on('end', () => resolve(message));
      stdin.on('error', reject);
    }
    catch(e) {
      reject(e);
    }
  });
}

async function getHTTPMessage() {
  const HTTPMessage = await getStdin();
  if(!HTTPMessage) {
    throw new Error(
      'An HTTP Message must be passed to stdin for this command.');
  }
  // this will create a request or response object
  // similar to node's default request object.
  const request = httpMessageParser(HTTPMessage);
  return request;
}

function makeHTTPHeaders(headers = {}) {
  let message = '';
  for(const key in headers) {
    let value = headers[key];
    if(Array.isArray(value)) {
      value = value.join(',');
    }
    message += `${key}: ${value}`;
  }
  return message;
}

program
  .command('c14n')
  .alias('cannonize')
  .action(async () => {
    try {
      const {headers} = program;
      const requestOptions = await getHTTPMessage();
      if(!headers) {throw new Error(
        '--headers required for command c14n|cannonize' +
        'ex: --header date,etag');}
      const includeHeaders = program.headers ? program.headers.split(/\s/) : '';
      const result = httpSigs.
        createSignatureString({includeHeaders, requestOptions});
      console.log(result);
      process.exit(0);
    } catch(e) {
      throw e;
      process.exit(1);
    }
  });

program
  .command('sign')
  .action(async cmd => {
    try {
      const {
        headers,
        keyId,
        privateKey,
        keyType,
        algorithm,
        created,
        expires
      } = program;
      const privateKeyFile = await readFile(privateKey);
      const includeHeaders = headers ? program.headers.split(/\s/) : '';
      const options = {
        algorithm,
        includeHeaders,
        keyId,
        signature
      };
      // TODO: implement a sign function
      // like this:
      // https://github.com/digitalbazaar/bedrock-test/blob/master/lib/helpers.js#L22
      const result = httpSigs.createAuthzHeader(options);
      throw new Error('command sign has not been implemented yet');
      console.log(result);
    } catch(e) {
      console.error(JSON.stringify(e));
      process.exit(1);
    }
  });

program
  .command('verify')
  .option('-s, --signature <signature>', 'Signature.')
  .action(async ({signature}) => {
    try {
      const reqJson = await getHTTPMessage();
      const {
        headers,
        keyId,
        privateKey,
        publicKey,
        keyType,
        algorithm,
        created,
        expires
      } = program;
      const publicKeyFile = await readFile(publicKey);
      // TODO: abstract middleware verify in this.
      // TODO: get options from program env variables.
      throw new Error('Not implemented yet.')
    } catch(e) {
      console.error('Error:', JSON.stringify(e, null, e), e);
      process.exit(1);
    }
  });

// all of the common options are accessed
// from program.name i.e. program.headers etc
program
  .version('0.0.1')
  .option('-H, --headers <headers>', 'A list of header names.')
  .option('-K, --keyId <keyId>', 'A Key Id string.')
  .option('-P, --private-key <privateKey>.',
    'A private key file name filename.')
  .option('-T, --key-type <keyType>',
    'The type of the keys.')
  .option('-U, --public-key <publicKey>.',
    'A public key file name filename.')
  .option('-A, --algorithm [algorithm]',
    'One of: rsa-sha1, hmac-sha1, rsa-sha256, hmac-sha256, hs2019.',
    /^(rsa-sha1|hmac-sha1|rsa-sha256|hmac-sha256|hs2019)$/i)
  .option('-C, --created [created]', 'The created param for the signature.')
  .option('-E, --expires [expires]', 'The expires param for the signature.')
  .parse(process.argv);
