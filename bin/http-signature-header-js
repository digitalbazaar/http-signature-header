#!/usr/bin/env node

const program = require('commander');
const httpSigs = require('../lib/');
const fs = require('fs');
const util = require('util');
const httpMessageParser = require('http-message-parser');

// this can be use to await paths to private keys and other files.
// also can get be used to dereference keyId in middleware
const readFile = util.promisify(fs.readFile);

/**
 * Simple wrapper around node's process.stdin.
 * This allows us to get the result of cat and other commands.
 *
 * @param {string} [encoding='utf8'] - The http message's encoding.
 *
 * @returns {Promise<string>} Should return the http message.
 */
async function getStdIn(encoding = 'utf8') {
  const {stdin} = process;
  let message = '';
  return new Promise((resolve, reject) => {
    try {
      stdin.setEncoding(encoding);
      stdin.on('readable', () => {
        let chunk;
        while((chunk = stdin.read())) {
          message += chunk;
        }
      });
      stdin.on('end', () => resolve(message));
    }
    catch(e) {
      reject(e);
    }
  });
}

async function getHttpMessage() {
  const httpMessage = await getStdIn();
  if(!httpMessage) {
    throw new Error('An Http Message must be passed to stdin.');
  }
  // this will create a request or response object
  // similar to node's default request object.
  const request = httpMessageParser(httpMessage);
  return request;
}

function makeHttpMessageOutgoing({status = '200 OK', version = '1.1', headers = {}}) {
  let message = `HTTP/${version} ${status}`;
  for(const key in headers) {
    let value = headers[key];
    if(Array.isArray(value)) {
      value = value.join(',');
    }
    message += `${key}: ${value}`;
  }
  return message;
}

program
  .command('c14n')
  .alias('C')
  .action(async () => {
    try {
      const {headers} = program;
      const requestOptions = await getHttpMessage();
      if(!headers) {throw new Error('--headers required');}
      const includeHeaders = program.headers ? program.headers.split(',') : '';
      const result = httpSigs.
        createSignatureString({includeHeaders, requestOptions});
      console.log(JSON.stringify(result));
      process.exit(0);
    } catch(e) {
      throw e;
      process.exit(1);
    }
  });

program
  .command('sign')
  .alias('S')
  .option('-s, --signature <signature>', 'Signature.')
  .action(async cmd => {
    try {
      const {signature} = cmd;
      const {
        headers,
        keyId,
        privateKey,
        privateKeyType,
        algorithm,
        created,
        expires
      } = program;
      const privateKeyFile = await readFile(privateKey);
      const includeHeaders = headers ? program.headers.split(',') : '';
      const options = {
        algorithm,
        includeHeaders,
        keyId,
        signature
      };
      // TODO: implement a sign function
      // like this:
      // https://github.com/digitalbazaar/bedrock-test/blob/master/lib/helpers.js#L22
      const result = httpSigs.createAuthzHeader(options);
      throw new Error('Not implemented yet');
      console.log(JSON.stringify(result));
    } catch(e) {
      console.error(JSON.stringify(e));
      process.exit(1);
    }
  });

program
  .command('verify')
  .alias('V')
  .action(async () => {
    try {
      const reqJson = await getHttpMessage();
      const {
        headers,
        keyId,
        privateKey,
        privateKeyType,
        algorithm,
        created,
        expires
      } = program;
      const privateKeyFile = await readFile(privateKey);
      // TODO: abstract middleware verify in this.
      // TODO: get options from program env variables.
      throw new Error('Not implemented yet.')
    } catch(e) {
      console.error('Error:', JSON.stringify(e, null, e), e);
      process.exit(1);
    }
  });

// all of the common options are accessed
// from program.name i.e. program.headers etc
program
  .version('0.0.1')
  .option('-H, --headers <headers>', 'A list of header names.')
  .option('-k, --keyId <keyId>', 'A Key Id <string>.')
  .option('-pk, --private-key <privateKey>.',
    'A private key file name <filename>.')
  .option('-pkt, --private-key-type <privateKeyType',
    'The type of the private key.')
  .option('-a, --algorithm [algorithm]',
    'One of: rsa-sha1, hmac-sha1, rsa-sha256, hmac-sha256, hs2019.',
    /^(rsa-sha1|hmac-sha1|rsa-sha256|hmac-sha256|hs2019)$/i)
  .option('-c, --created [created]', 'The created param for the signature.')
  .option('-e, --expires [expires]', 'The expires param for the signature.')
  .parse(process.argv);
