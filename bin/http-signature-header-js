#!/usr/bin/env node

/**
 * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.
*/

const program = require('commander');
const crypto = require('crypto');
const httpSigs = require('../lib/');
const fs = require('fs');
const util = require('util');
const httpMessageParser = require('http-message-parser');
const jsprim = require('jsprim');

// this can be use to await paths to private keys and other files.
// also can get be used to dereference keyId in middleware
const readFile = util.promisify(fs.readFile);

/**
 * Simple wrapper around node's process.stdin.
 * This allows us to get the result of cat and other commands.
 *
 * @param {string} [encoding='utf8'] - The http message's encoding.
 *
 * @returns {Promise<string>} Should return the http message.
 */
async function getStdin(encoding = 'utf8') {
  const {stdin} = process;
  let message = '';
  return new Promise((resolve, reject) => {
    try {
      stdin.setEncoding(encoding);
      stdin.on('readable', () => {
        let chunk;
        while((chunk = stdin.read())) {
          message += chunk;
        }
      });
      stdin.on('end', () => resolve(message));
      stdin.on('error', reject);
    }
    catch(e) {
      reject(e);
    }
  });
}

/**
 * Gets a file then converts it to json.
 *
 * @param {string} file - File path.
 *
 * @returns {Object} The json object.
 */
async function getJSON(file) {
  const keyData = await readFile(file);
  return JSON.parse(keyData);
}

async function getHTTPMessage() {
  const HTTPMessage = await getStdin();
  if(!HTTPMessage) {
    throw new Error(
      'An HTTP Message must be passed to stdin for this command.');
  }
  // this will create a request or response object
  // similar to node's default request object.
  return httpMessageParser(HTTPMessage);
}

function makeHTTPHeaders(headers = {}) {
  let message = '';
  for(const key in headers) {
    let value = headers[key];
    if(Array.isArray(value)) {
      value = value.join(',');
    }
    message += `${key}: ${value}\n`;
  }
  return message;
}

function getHTTPSignatureAlgorithm(algorithm) {
  if(algorithm === true) {
    throw new Error(
      'Your algorithm is not in the current HTTP Signatures registry');
  }
  switch(algorithm.toLowerCase()) {
    case 'hs2019': {
      return {
        hash: crypto.createHash('SHA512'),
        dsa: ['rsa', 'hmac', 'ed', 'ecdsa']
      };
    }
    default: {
      throw new Error(`${algorithm} is deprecated or unsupported}`);
    }
  }
}

/**
 * Runs validates on various fields.
 *
 * @param {Object} options - Command line options.
 */
function validate(options) {
  const now = Date.now();
  if(!isNaN(options.created)) {
    if(options.created > now) {
      throw new Error(
        'Invalid created. Your created parameter is in the future');
    }
  }
  if(!isNaN(options.expires)) {
    if(options.expires < now) {
      throw new Error('Your signature has expired.');
    }
  }
}

program
  .command('c14n')
  .alias('canonicalize')
  .action(async () => {
    try {
      const {headers} = program;
      const requestOptions = await getHTTPMessage();
      if(!headers) {throw new Error(
        '--headers required for command c14n|canonicalize' +
        'ex: --header date,etag');}
      const includeHeaders =
        program.headers ? program.headers.split(/\s+/) : '';
      const result = httpSigs.
        createSignatureString({includeHeaders, requestOptions});
      console.log(result);
      process.exit(0);
    } catch(e) {
      console.error('c14n command failed : ' + e);
      process.exit(1);
    }
  });

program
  .command('sign')
  .action(async () => {
    try {
      const {
        headers, keyId, privateKey,
        algorithm
      } = program;
      validate(program);
      const privateKeyFile = await readFile(privateKey);
      const includeHeaders = headers ? program.headers.split(/\s+/) : '';
      const requestOptions = await getHTTPMessage();
      const options = {
        keyId,
        algorithm,
        includeHeaders,
        keyId,
        requestOptions,
        privateKey: privateKeyFile
      };
      /**
       * Add HTTPSignatures headers to a given requestOptions object.
       * This is compatible with both request and axios libraries.
       * TODO: factor out to new npm package.
       *
       * @param {Object} options - Options for the request.
       * @param {string} options.algorithm - The signing algorithm
       * to use (rsa-sha256, hs2019).
       * @param {Object} options.requestOptions - The request options.
       * @param {string} options.keyId - A valid IRI
       * that resolves to a public key.
       * @param {Array<string>} options.includeHeaders - Which headers
       * to use in the Signing String.
       *
       * @returns {Object} The response headers.
      */
      const createHttpSignatureRequest = async (
        {algorithm = 'hs2019', privateKey, keyId,
          requestOptions, includeHeaders = []}) => {
        // get metadata from public key
        const {authentication} = await getJSON(keyId);
        const [{type: publicKeyType}] = authentication;
        if(!publicKeyType) {
          throw new Error('Expected public key to have key type metadata');
        }
        requestOptions.headers = requestOptions.headers || {};
        if(!requestOptions.headers.date) {
          requestOptions.headers.date = jsprim.rfc1123(new Date());
        }
        const httpSignatureAlgorithm = getHTTPSignatureAlgorithm(algorithm);
        const plaintext = httpSigs.createSignatureString(
          {includeHeaders, requestOptions});
        httpSignatureAlgorithm.hash.update(plaintext);
        const authzHeaderOptions = {includeHeaders, keyId};
        // TODO add signing support for HMAC, ECDSA, P-256,
        // Ed25519ph, Ed25519ctx, and Ed25519
        // ANSI X9.62-2005
        const keyType = publicKeyType.trim().toLowerCase();
        const valid = httpSignatureAlgorithm.dsa
          .reduce((any, current) => {
            if(any) {
              return any;
            }
            return keyType.startsWith(current);
          }, false);
        if(!valid) {
          throw new Error(`Unsupported signing algorithm ${keyType}`);
        }
        const keyObj = crypto.createPrivateKey(privateKey);
        const hashText = Buffer.from(
          httpSignatureAlgorithm.hash.digest('utf8'), 'utf8');
        authzHeaderOptions.signature =
          await crypto.sign(null, hashText, keyObj).toString('base64');
        requestOptions.headers.Authorization = httpSigs.createAuthzHeader(
          authzHeaderOptions);
        return requestOptions.headers;
      };
      const result = await createHttpSignatureRequest(options);
      const message = makeHTTPHeaders(result);
      console.log(message);
      process.exit(0);
    } catch(e) {
      console.error(e);
      //console.error('Sign Error', JSON.stringify(e));
      process.exit(1);
    }
  });

// TODO implement verify
program
  .command('verify')
  .action(async () => {
    try {
      const reqJson = await getHTTPMessage();
      const {
        headers, keyId, privateKey, publicKey,
        keyType, algorithm, created, expires
      } = program;
      const publicKeyFile = await readFile(publicKey);
      // TODO: abstract middleware verify in this.
      // TODO: get options from program env variables.
      throw new Error('Command verify has not been implemented yet.');
      process.exit(0);
    } catch(e) {
      console.error('Verification Error:', JSON.stringify(e, null, e), e);
      process.exit(1);
    }
  });

// all of the common options are accessed
// from program.name i.e. program.headers etc
program
  .version('0.0.1')
  .option('-d, --headers <headers>', 'A list of header names.')
  .option('-k, --keyId <keyId>', 'A Key Id string.')
  .option('-p, --private-key <privateKey>.',
    'A private key file name filename.')
  .option('-t, --key-type <keyType>',
    'The type of the keys.')
  .option('-u, --public-key <publicKey>.',
    'A public key file name filename.')
  .option('-a, --algorithm [algorithm]',
    'One of: rsa-sha1, hmac-sha1, rsa-sha256, hmac-sha256, hs2019.',
    /^(rsa-sha1|hmac-sha1|rsa-sha256|hmac-sha256|hs2019)$/i)
  .option('-c, --created [created]', 'The created param for the signature.')
  .option('-e, --expires [expires]', 'The expires param for the signature.')
  .parse(process.argv);
